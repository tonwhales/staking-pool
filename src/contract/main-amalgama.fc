
(slice) elector_address() {
    var elector = config_param(1).begin_parse().preload_uint(256);
    return begin_cell()
           .store_uint(4, 3).store_uint(0xff, 8).store_uint(elector, 256)
           .end_cell()
           .begin_parse();
}

(slice) config_address() {
    var config = config_param(0).begin_parse().preload_uint(256);
    return begin_cell()
           .store_uint(4, 3).store_uint(0xff, 8).store_uint(config, 256)
           .end_cell()
           .begin_parse();
}

(int) equal_slices (slice s1, slice s2) asm "SDEQ";

;;
;; Parsing of a command from wallet
;;
(slice, (int)) ~parse_text_command(slice in_msg) {
    int op = 0;
    ;; 4 possible commands lock, stake, recover, withdraw
    int first_char = in_msg~load_uint(8);
    if (first_char == 108) { ;; l
      throw_unless(505, in_msg~load_uint(24) == 7299947); ;; ock
      op = 0x6c6f636b; ;; == lock
    }
    if (first_char == 114 ) { ;; r
      throw_unless(505, in_msg~load_uint(48) == 111477746197874); ;; ecover
      op = 0x7265636f; ;; == reco(ver)
    }
    if (first_char == 115 ) { ;; s
      throw_unless(505, in_msg~load_uint(32) == 1952541541); ;; take
      op = 0x7374616b; ;; stak(e)
    }
    if (first_char == 119 ) { ;; w
      throw_unless(505, in_msg~load_uint(56) == 29682864265257335); ;; ithdraw
      op = 0x77697468; ;; with(draw)
    }
    return (in_msg, (op));
}

(int, int) encode_number_to_text(int number) {
  int len = 0;
  int value = 0;
  int mult = 1;
  do {
    (number, int res) = number.divmod(10);
    value = value + (res + 48) * mult;
    mult = mult * 256;
    len = len + 1;
  } until (number == 0);
  return (len, value);
}

builder store_grams_string(builder msg, int amount) {
  (int ceil, int res) = divmod(amount, 1000000000);
  (int cl, int cv) = encode_number_to_text(ceil);
  msg = msg.store_uint(cv, cl * 8 );
  msg = msg.store_uint(46, 8); ;; "."
  (int rl, int rv) =  encode_number_to_text(res);
  repeat( 9 - rl ) {
    msg = msg.store_uint(48, 8); ;; " "
  }
  return msg.store_uint(rv, rl * 8);
}

() send_text_stake_accept_message(slice addr, int stake) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_uint(126943687828768, 48) ;; "stake "
    .store_grams_string(stake)
    .store_uint(597313372290408539492, 72); ;; " accepted"
    
  send_raw_message(msg.end_cell(), 1); ;; Pay gas separately
}

() send_text_lock_accept_message(slice addr, int locked) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_uint(126943687828768, 48) ;; "stake "
    .store_grams_string(locked)
    .store_uint(9126424919893348, 56); ;; " locked"
    
  send_raw_message(msg.end_cell(), 1); ;; Pay gas separately
}

() send_text_withdraw_message(slice addr, int value) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(value)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_uint(210982622422653884098403377339833676834051106906582061058449761145002618732, 248); ;; "withdrawal from nomination pool"

  send_raw_message(msg.end_cell(), 1); ;; Pay gas separately
}

;;
;; Storage Format
;;
;; - seqno (32 bit)
;; - owner (address)
;; - seed (32 bytes)
;; - accept_stakes (1bit)
;; - working amount (coins)
;; - locked amount (coins)
;; - nominators (dict)

(int, slice, int, int, int, int, cell) load_data() {
  var ds = get_data().begin_parse();
  return (
    ds~load_uint(32),   ;; data: seqno
    ds~load_msg_addr(), ;; data: owner
    ds~load_uint(256),  ;; data: seed
    ds~load_uint(1),    ;; data: accept_stakes
    ds~load_grams(),    ;; data: working coins
    ds~load_grams(),    ;; data: locked coins
    ds~load_dict()      ;; data: nominators
  );
}

() save_data(int seqno, slice owner, int seed, int accept_stakes, int working_coins, int locked_coins, cell nominators) impure {
  set_data(begin_cell()
    .store_uint(seqno, 32)
    .store_slice(owner)
    .store_uint(seed, 256)
    .store_uint(accept_stakes, 1)
    .store_grams(working_coins)
    .store_grams(locked_coins)
    .store_dict(nominators)
  .end_cell());
}

;;
;; Nominator storage
;; - stake (coins)
;; - locked (coins)
;; 

(int, int) get_nominator_data (cell nominators, int address_hash) {
  (slice nominator, int found) = nominators.udict_get?(256, address_hash);
  if( ~ found) {
    return (0, 0);
  }
  return (nominator~load_grams(), nominator~load_grams());
}

(cell, ()) ~set_nominator_data (cell nominators,
                                int address_hash,
                                int stake, 
                                int locked
) {
  if (stake + locked > 0) {
    nominators~udict_set_builder(256, address_hash, begin_cell()
      .store_grams(stake)
      .store_grams(locked)
    );
  } else {
    nominators~udict_delete?(256, address_hash);
  }
  return (nominators, ());
}

_ nominators_list() method_id {
    (int seqno, slice owner, int seed, int accept_stakes, int working_amount, int locked_amount, cell nominators) = load_data();
    var l = nil;
    var id = (1 << 255) + ((1 << 255) - 1);
    do {
        (id, var cs, var f) = nominators.udict_get_prev?(256, id);
        if (f) {
            var (stake, locked) = (cs~load_grams(), cs~load_grams());
            l = cons([id, [stake, locked]], l);
        }
    } until (~ f);
    return (l);
}

_ balance() method_id {
    (int seqno, slice owner, int seed, int accept_stakes, int working_amount, int locked_amount, cell nominators) = load_data();
    [int pool_balance, cell cur_col] = get_balance();
    return (pool_balance, working_amount, locked_amount);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {

    ;;
    ;; Load message metadata
    ;;

    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();
    (int s_addr_wc, int s_addr_hash)  = parse_std_addr(s_addr);
    
    ;;
    ;; Ignore all bounced messages
    ;; NOTE: While this is a strange way to do so, but it would be too complicated and test
    ;;       bounced messages. Much better to have an ability to fix stuff with master key instead.
    ;;

    if (flags & 1) {
        return ();
    }

    ;;
    ;; Load config
    ;;
    
    (int seqno, slice owner, int seed, int accept_stakes, int working_amount, int locked_amount, cell nominators) = load_data();

    ;;
    ;; Parse command
    ;;

    int op = in_msg~load_uint(32);
    if ( ~ op ) {
        op = in_msg~parse_text_command();
    }

    ;;
    ;; Add stake command
    ;;

    if (op == 0x7374616b) {

        ;; Check inputs
        int stake_fee = 1000000000; ;; 1 Gram
        int min_stake = 1000000000; ;; 1 Gram
        int stake = msg_value - stake_fee; ;; New stake
        throw_unless(393, stake >= min_stake); ;; Check if stake is more than minimum required stake
        throw_unless(394, ~ s_addr_wc); ;; Only workchain nominators
        
       ;; Update global working amount
        working_amount = working_amount + stake;

        ;; Update nominator state
        (int active, int locked) = nominators.get_nominator_data(s_addr_hash);
        throw_if(394, locked); ;; Do not allow staking when locked
        active = active + stake;
        nominators~set_nominator_data(s_addr_hash, active, locked);

        ;; Persist data
        save_data(seqno, owner, seed, accept_stakes, working_amount, locked_amount, nominators);

        ;; Send response
        send_text_stake_accept_message(s_addr, stake);

        return ();
    }
    
    ;;
    ;; Lock stake command
    ;;

    if (op == 0x6c6f636b) {
        
        ;; Check inputs
        int lock_fee = 1000000000; ;; 1 Gram
        throw_unless(393, msg_value >= lock_fee); ;; Check if message value is more than minimum lock fee

        ;; Lock funds
        (int active, int locked) = nominators.get_nominator_data(s_addr_hash);
        throw_if(394, locked); ;; If already locked
        throw_if(395, ~ active); ;; If nothing to lock
        locked = active;
        active = 0;
        working_amount = working_amount - locked;
        locked_amount = locked_amount + locked;

        ;; Persist
        nominators~set_nominator_data(s_addr_hash, active, locked);
        save_data(seqno, owner, seed, accept_stakes, working_amount, locked_amount, nominators);

        ;; Send response
        send_text_lock_accept_message(s_addr, locked);

        return ();
    }

    ;;
    ;; Withdraw stake command
    ;;

    if (op == 0x77697468) {
        
        ;; Check inputs
        int withdraw_fee = 1000000000; ;; 1 Gram
        throw_unless(393, msg_value >= withdraw_fee); ;; Check if message value is more than minimum lock fee

        ;; Adjust balance
        (int active, int locked) = nominators.get_nominator_data(s_addr_hash);
        throw_if(394, ~ locked); ;; If not locked
        throw_if(395, ~ active); ;; If nothing to withdraw (should not be possible)
        locked_amount = locked_amount - locked;

        ;; Persist
        nominators~set_nominator_data(s_addr_hash, 0, 0);
        save_data(seqno, owner, seed, accept_stakes, working_amount, locked_amount, nominators);

        ;; Send response
        send_text_withdraw_message(s_addr, locked);

        return ();
    }

    ;;
    ;; Unable to process message
    ;;

    throw(404);
}

() recv_external(slice in_msg) impure {
    (int seqno, slice owner, int seed, int accept_stakes, int working_amount, int locked_amount, cell nominators) = load_data();

    ;; Deployment message
    if (seqno == 0) {
        seqno = seqno + 1;
        save_data(seqno, owner, seed, accept_stakes, working_amount, locked_amount, nominators);
        accept_message();
    } else {
        throw(100);
    }
}

